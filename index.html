<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>パニックキャット - 1000レベルへの挑戦</title>
    
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Bootstrap Icons -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.0/font/bootstrap-icons.css">
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@400;800&display=swap" rel="stylesheet">

    <style>
        body {
            margin: 0; padding: 0;
            background-color: #212529;
            font-family: 'M PLUS Rounded 1c', sans-serif;
            overflow: hidden; /* スクロール禁止 */
            touch-action: none; /* スマホでのズーム等禁止 */
            width: 100vw; height: 100vh;
            display: flex;
            justify-content: center; align-items: center;
            color: white; user-select: none;
        }

        #game-wrapper {
            position: relative; 
            width: 100%; height: 100%;
            max-width: 100%; max-height: 100%;
            display: flex; justify-content: center; align-items: center;
            background-color: #333;
        }

        canvas#gameCanvas {
            display: block; 
            box-shadow: 0 0 40px rgba(0,0,0,0.6);
            background-color: #87CEEB;
            max-width: 100%; max-height: 100%;
            object-fit: contain;
        }

        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; justify-content: center; align-items: center;
            z-index: 100;
        }

        /* UI Panels */
        .game-panel {
            background: rgba(20, 20, 20, 0.96); padding: 1.5rem;
            border-radius: 1rem; text-align: center; pointer-events: auto;
            border: 3px solid #fff;
            width: 700px; 
            max-width: 95%; 
            max-height: 95vh; 
            overflow-y: auto;
            display: none;
            box-shadow: 0 20px 50px rgba(0,0,0,0.9); backdrop-filter: blur(5px);
        }
        .game-panel.active { display: block; animation: popIn 0.2s ease-out; }
        @keyframes popIn { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }

        h1 { color: #FFD700; text-shadow: 3px 3px 0 #000; font-weight: 800; margin-bottom: 0.5rem; font-size: clamp(1.5rem, 5vw, 2.5rem); }
        h2 { font-size: 1.1rem; color: #ccc; margin-bottom: 1.5rem; }

        /* HUD */
        #hud {
            position: absolute; top: 15px; left: 20px;
            display: flex; flex-direction: column; gap: 5px;
            font-size: clamp(16px, 4vw, 20px); font-weight: 900;
            text-shadow: 2px 2px 0px black, -1px -1px 0 #000;
            pointer-events: none; z-index: 10;
        }
        .hud-row { display: flex; gap: 15px; align-items: center; }

        /* Buttons */
        #pause-container {
            position: absolute; top: 15px; right: 20px;
            pointer-events: auto; z-index: 11; display: none;
        }

        .hud-btn {
            background: rgba(0,0,0,0.5); border: 2px solid white; color: white;
            width: 40px; height: 40px; border-radius: 8px; font-size: 20px;
            cursor: pointer; display: flex; justify-content: center; align-items: center;
            transition: background 0.1s;
        }
        .hud-btn:hover { background: rgba(255,255,255,0.2); }

        #suicide-btn {
            pointer-events: auto; background: #333; border: 2px solid #ff4444; color: #ff4444;
            width: 40px; height: 40px; border-radius: 50%; display: flex;
            justify-content: center; align-items: center; cursor: pointer; font-size: 20px;
            opacity: 1; transition: opacity 0.2s;
        }
        #suicide-btn.disabled { opacity: 0.3; pointer-events: none; }
        #suicide-btn:active { transform: scale(0.9); background: #500; }

        /* Result Maps */
        #result-map-canvas, #history-route-canvas { 
            width: 100%; height: 150px; background: #87CEEB; border: 2px solid #fff; margin-bottom: 10px; border-radius: 8px; 
        }

        /* Shop Items */
        .shop-item { display: flex; justify-content: space-between; align-items: center; padding: 12px; border-bottom: 1px solid #444; }
        .shop-item:last-child { border-bottom: none; }
        .price-container { text-align: right; display: flex; flex-direction: column; align-items: flex-end; }
        .old-price { position: relative; color: #999; font-size: 0.9rem; display: inline-block; margin-right: 8px; }
        .old-price::before { content: ''; position: absolute; left: 0; top: 50%; width: 100%; height: 2px; background: #ff4444; transform: rotate(-10deg); }
        .new-price { font-family: monospace; font-weight: bold; color: #FFD700; font-size: 1.2rem; }
        .discount-badge { background: #e91e63; color: white; font-size: 0.7rem; padding: 2px 6px; border-radius: 4px; margin-left: 5px; vertical-align: text-top; }
        .saved-text { font-size: 0.75rem; color: #00ff88; display: block; text-align: right; }
        .coin-calc { font-size: 0.75rem; color: #aaa; margin-top: 4px; font-family: monospace; }
        .shop-section-title { background: #444; color: #ddd; padding: 5px; font-size: 0.9rem; font-weight: bold; text-align: left; margin-top: 10px; border-radius: 4px; }

        /* Level Grid */
        #level-grid-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(65px, 1fr));
            gap: 8px;
            padding: 10px;
            max-height: 60vh;
            overflow-y: auto;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            border: 1px solid #555;
        }
        .level-btn {
            font-family: monospace;
            font-weight: bold;
            font-size: 1.1rem;
            padding: 8px 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            line-height: 1.1;
        }
        #level-grid-container::-webkit-scrollbar { width: 10px; }
        #level-grid-container::-webkit-scrollbar-track { background: #222; }
        #level-grid-container::-webkit-scrollbar-thumb { background: #555; border-radius: 5px; }
        #level-grid-container::-webkit-scrollbar-thumb:hover { background: #777; }

        /* Mobile Controls */
        #mobile-controls {
            position: absolute; bottom: 10px; left: 0; width: 100%; height: 140px;
            pointer-events: none; display: none; justify-content: space-between;
            padding: 0 20px; box-sizing: border-box; z-index: 50;
        }
        .control-group { pointer-events: auto; display: flex; gap: 10px; align-items: flex-end; padding-bottom: 10px; }
        .control-btn {
            background: rgba(255, 255, 255, 0.2); border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%; width: 60px; height: 60px;
            display: flex; justify-content: center; align-items: center;
            font-size: 24px; color: white; backdrop-filter: blur(4px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.3); user-select: none;
        }
        .control-btn:active, .control-btn.pressed { background: rgba(255, 255, 255, 0.4); transform: scale(0.95); }
        .btn-action { width: 80px; height: 80px; font-size: 16px; font-weight: bold; border-radius: 20px; }
        .btn-jump { background: rgba(255, 60, 60, 0.4); border-color: #ffcccc; }
        .btn-sub { background: rgba(60, 255, 60, 0.4); border-color: #ccffcc; border-radius: 50%; width: 55px; height: 55px; font-size: 12px; margin-bottom: 5px; }
        .btn-hip { background: rgba(60, 60, 255, 0.4); border-color: #ccccff; }

        .status-badge { background: #e91e63; color: white; padding: 2px 8px; border-radius: 4px; font-size: 0.8rem; animation: pulse 1s infinite; display: none; }
        @keyframes pulse { 0% { opacity: 0.7; } 50% { opacity: 1; } 100% { opacity: 0.7; } }

        .cheat-warning-box { border: 2px solid #ff4444; background: rgba(50, 0, 0, 0.8); color: #ffcccc; padding: 15px; border-radius: 8px; margin-bottom: 15px; font-size: 0.9rem; text-align: left; }
        
        #initial-lives-section { display: none; }
    </style>
</head>
<body>

<div id="game-wrapper">
    <canvas id="gameCanvas"></canvas>

    <!-- HUD -->
    <div id="hud">
        <div class="hud-row">
            <div id="suicide-btn" onclick="confirmSuicide()"><i class="bi bi-skull-fill"></i></div>
            <div><i class="bi bi-flag-fill" style="color:#FFD700;"></i> <span id="disp-level">1</span></div>
            <div><i class="bi bi-heart-fill" style="color:#ff4d4d;"></i> <span id="disp-lives">10</span></div>
            <div><i class="bi bi-circle-fill text-warning"></i> <span id="disp-coins">0</span></div>
        </div>
        <div class="hud-row">
            <div style="font-size: 24px; color: #00ffcc;"><i class="bi bi-stopwatch"></i> <span id="disp-time">00:00.00</span></div>
            <div id="cheat-status" class="status-badge">CHEAT</div>
        </div>
    </div>

    <!-- Pause Button -->
    <div id="pause-container">
        <button class="hud-btn" onclick="togglePause()"><i class="bi bi-pause-fill"></i></button>
    </div>

    <div id="ui-layer">
        <!-- Main Menu -->
        <div id="menu-panel" class="game-panel active">
            <h1>パニックキャット</h1>
            <h2 class="text-danger fw-bold">〜理不尽な罠と1000の絶望〜</h2>
            
            <div class="d-flex justify-content-center gap-2 mb-3 flex-wrap">
                <button class="btn btn-info btn-sm fw-bold px-4" onclick="showHelp()"><i class="bi bi-question-circle"></i> 遊び方</button>
                <button class="btn btn-success btn-sm fw-bold px-4" onclick="showShop()"><i class="bi bi-cart-fill"></i> ショップ</button>
                <button class="btn btn-secondary btn-sm fw-bold px-4" onclick="showHistory()"><i class="bi bi-clock-history"></i> 履歴</button>
                <button class="btn btn-danger btn-sm fw-bold px-4" onclick="showCheats()"><i class="bi bi-lightning-fill"></i> チート</button>
            </div>

            <div class="seed-box bg-dark p-2 rounded border border-secondary mb-3 d-inline-block">
                <span class="font-monospace">SEED: <span id="menu-seed-val">---</span></span>
                <i class="bi bi-clipboard copy-btn ms-2 text-primary" style="cursor:pointer" onclick="copySeed()" title="コピー"></i>
            </div>

            <div class="bg-dark p-3 rounded border border-secondary mb-3 mx-auto" style="max-width: 500px;">
                <div class="d-flex justify-content-between align-items-center mb-3">
                    <span class="small text-light">進捗状況</span>
                    <span class="small text-warning fw-bold" id="max-reached-display">到達: Lv.1</span>
                </div>

                <button class="btn btn-outline-warning w-100 fw-bold mb-3" onclick="showLevelSelect()">
                    <i class="bi bi-grid-3x3-gap-fill"></i> レベルを選択する (1 - 1000)
                </button>

                <div id="initial-lives-section" class="mb-3 text-start border-top border-secondary pt-2">
                    <label class="form-label text-warning mb-0 small">初期残機設定: <span id="lives-val">10</span></label>
                    <input type="range" class="form-range mt-1" min="1" max="100" value="10" id="lives-range">
                    <div class="text-muted small">※この設定は初回のみ適用されます</div>
                </div>

                <button class="btn btn-warning btn-lg w-100 fw-bold py-3" style="box-shadow: 0 4px 0 #b48900;" onclick="startGame(gameData.maxReachedLevel)">
                    <i class="bi bi-play-fill"></i> 続きから遊ぶ (Lv.<span id="cont-level-display">1</span>)
                </button>

                <div class="mt-3">
                    <button class="btn btn-danger btn-sm fw-bold" onclick="resetAllData()">
                        <i class="bi bi-trash-fill"></i> データ初期化
                    </button>
                </div>
            </div>
        </div>

        <!-- Level Select Panel -->
        <div id="level-select-panel" class="game-panel">
            <h3 class="text-warning fw-bold mb-3"><i class="bi bi-grid-3x3-gap-fill"></i> レベル選択</h3>
            <div id="level-grid-container" class="mb-3"></div>
            <button class="btn btn-light fw-bold w-100" onclick="showMenu()">
                <i class="bi bi-arrow-return-left"></i> メニューへ戻る
            </button>
        </div>

        <!-- Shop Panel -->
        <div id="shop-panel" class="game-panel">
            <h3 class="text-warning fw-bold"><i class="bi bi-cart-fill"></i> アイテムショップ</h3>
            <div class="d-flex justify-content-between bg-dark p-3 rounded mb-3 border border-secondary">
                <span class="fs-5">所持コイン:</span>
                <span class="text-warning fw-bold fs-4" id="shop-coins">0</span>
            </div>
            <div class="mb-3 text-start" id="shop-list" style="max-height:450px; overflow-y:auto;"></div>
            <button class="btn btn-light fw-bold w-100" onclick="showMenu()"><i class="bi bi-arrow-return-left"></i> 戻る</button>
        </div>

        <!-- History Panel -->
        <div id="history-panel" class="game-panel">
            <h3 class="text-secondary fw-bold"><i class="bi bi-journal-text"></i> プレイ履歴</h3>
            <div class="mb-3" style="max-height:300px; overflow-y:auto;">
                <table class="table table-dark table-sm table-striped text-start small mb-0" style="vertical-align: middle;">
                    <thead><tr><th>日時</th><th>LV</th><th>Time</th><th>Coin</th><th><i class="bi bi-heart-fill text-danger"></i></th><th>Map</th></tr></thead>
                    <tbody id="history-table-body"></tbody>
                </table>
            </div>
            <button class="btn btn-light fw-bold w-100" onclick="showMenu()"><i class="bi bi-arrow-return-left"></i> 戻る</button>
        </div>

        <!-- Route View Modal -->
        <div id="route-view-panel" class="game-panel">
            <h3 class="text-primary fw-bold">ルート確認</h3>
            <p class="mb-2 text-secondary">Level <span id="route-view-level"></span></p>
            <div class="bg-dark p-2 rounded mb-3 border border-secondary">
                <canvas id="history-route-canvas"></canvas>
            </div>
            <button class="btn btn-light fw-bold w-100" onclick="showHistory()"><i class="bi bi-arrow-return-left"></i> 戻る</button>
        </div>

        <!-- Cheat Settings -->
        <div id="cheat-panel" class="game-panel">
            <h3 class="text-danger fw-bold"><i class="bi bi-exclamation-triangle-fill"></i> チート設定</h3>
            <div class="cheat-warning-box mx-auto">
                <i class="bi bi-exclamation-triangle-fill"></i> チート機能を使用すると、ゲームの難易度が崩壊します。<br>
                ・クリアしても「ベストタイム」は記録されません。<br>
            </div>
            <div class="text-start bg-dark p-3 rounded border border-secondary mb-3 d-grid gap-2 mx-auto" style="grid-template-columns: 1fr 1fr;">
                <div class="form-check form-switch"><input class="form-check-input" type="checkbox" id="cheat-flight"><label class="form-check-label" for="cheat-flight">空を飛ぶ</label></div>
                <div class="form-check form-switch"><input class="form-check-input" type="checkbox" id="cheat-god"><label class="form-check-label" for="cheat-god">無敵モード</label></div>
                <div class="form-check form-switch"><input class="form-check-input" type="checkbox" id="cheat-speed"><label class="form-check-label" for="cheat-speed">超スピード</label></div>
                <div class="form-check form-switch"><input class="form-check-input" type="checkbox" id="cheat-infinite"><label class="form-check-label" for="cheat-infinite">無限ジャンプ</label></div>
                <div class="form-check form-switch"><input class="form-check-input" type="checkbox" id="cheat-inf-coin"><label class="form-check-label" for="cheat-inf-coin">コイン無限 (∞)</label></div>
                <div class="form-check form-switch"><input class="form-check-input" type="checkbox" id="cheat-unlock" onchange="generateLevelGrid()"><label class="form-check-label" for="cheat-unlock">全レベル開放</label></div>
            </div>
            <div class="bg-dark p-3 rounded border border-secondary mb-3 mx-auto">
                <h5 class="text-warning text-start">数値指定変更</h5>
                <div class="input-group mb-2">
                    <span class="input-group-text bg-secondary text-light border-secondary">コイン</span>
                    <input type="number" class="form-control bg-dark text-light border-secondary" id="cheat-coin-val" placeholder="枚数">
                    <button class="btn btn-warning" onclick="setCheatCoins()">設定</button>
                </div>
                <div class="input-group">
                    <span class="input-group-text bg-secondary text-light border-secondary">残機数</span>
                    <input type="number" class="form-control bg-dark text-light border-secondary" id="cheat-life-val" placeholder="残機">
                    <button class="btn btn-danger" onclick="setCheatLives()">設定</button>
                </div>
            </div>
            <button class="btn btn-light fw-bold w-100" onclick="showMenu()"><i class="bi bi-x-lg"></i> 閉じる</button>
        </div>

        <!-- Pause Menu -->
        <div id="pause-panel" class="game-panel" style="border-color: #0dcaf0;">
            <h1 class="display-4 text-info fw-bold">PAUSE</h1>
            <p class="mb-4">一時停止中</p>
            <div class="d-grid gap-3 mx-auto" style="max-width: 400px;">
                <button class="btn btn-light btn-lg fw-bold" onclick="togglePause()">
                    <i class="bi bi-play-fill"></i> ゲーム再開
                </button>
                <button class="btn btn-outline-light" onclick="showMenu()">
                    <i class="bi bi-house-door-fill"></i> メニューへ戻る
                </button>
            </div>
        </div>

        <!-- Help Modal -->
        <div id="help-panel" class="game-panel">
            <h3 class="text-info fw-bold">遊び方 (要注意)</h3>
            <div class="text-start bg-dark p-3 rounded border border-secondary mb-3 small mx-auto">
                <p class="lead mb-3 text-danger fw-bold">※このゲームは極めて理不尽です。</p>
                <ul class="text-light">
                    <li>見た目通りの床とは限りません。</li>
                    <li>アイテムが助けてくれるとは限りません。</li>
                    <li>何もないところからブロックが現れます。</li>
                    <li><strong>New!</strong> リスポーン時に周囲の敵が消えるようになりました。</li>
                    <li><strong>New!</strong> トラップの数が大幅に増加し、コーステーマも増えました。</li>
                    <li><strong class="text-danger">New!</strong> 天井のトゲはジャンプで触れると即死します。</li>
                </ul>
                <div class="row mt-4">
                    <div class="col-md-6 mb-3">
                        <h5 class="text-warning border-bottom border-secondary pb-1"><i class="bi bi-keyboard"></i> PC操作</h5>
                        <ul class="ps-3 mb-0 text-light">
                            <li><strong>← → / A D</strong> : 移動</li>
                            <li><strong>Space / ↑</strong> : ジャンプ</li>
                            <li><strong>Shift</strong> : ダッシュ</li>
                            <li><strong>↓ / S</strong> : しゃがむ / ヒップドロップ</li>
                            <li><strong>Esc</strong> : 一時停止</li>
                        </ul>
                    </div>
                    <div class="col-md-6">
                        <h5 class="text-warning border-bottom border-secondary pb-1"><i class="bi bi-phone"></i> スマホ/タブレット操作</h5>
                        <ul class="ps-3 mb-0 text-light">
                            <li><strong>左右ボタン</strong> : 移動</li>
                            <li><strong>JUMP</strong> : ジャンプ</li>
                            <li><strong>走る</strong> : ダッシュ</li>
                            <li><strong>しゃがむ</strong> : しゃがむ</li>
                            <li><strong>ヒップ</strong> : 空中で急降下</li>
                        </ul>
                    </div>
                </div>
            </div>
            <button class="btn btn-light fw-bold w-100" onclick="showMenu()"><i class="bi bi-x-lg"></i> 閉じる</button>
        </div>

        <!-- Game Over -->
        <div id="gameover-panel" class="game-panel" style="border-color: #ff4d4d;">
            <h1 class="display-4 text-danger fw-bold">GAME OVER</h1>
            <p class="mb-4 text-light">残機がなくなりました</p>
            <div class="d-grid gap-2 mt-4 text-start mx-auto" style="max-width: 500px;">
                <button class="btn btn-light fw-bold py-3" onclick="retryGame()" id="go-retry-btn" disabled>
                    コンティニュー <span class="d-block small fw-normal text-secondary">※ショップで残機を買ってください</span>
                </button>
                <button class="btn btn-danger fw-bold py-3" onclick="continueNegative()">
                    <i class="bi bi-skull"></i> 残機マイナスで継続 <span class="d-block small fw-normal text-light">※借金状態でその場復活</span>
                </button>
                <button class="btn btn-outline-light" onclick="showMenu()"><i class="bi bi-house-door-fill"></i> メニューへ戻る</button>
            </div>
        </div>

        <!-- Suicide Confirm -->
        <div id="suicide-panel" class="game-panel" style="border-color: #ff4444;">
            <h3 class="text-danger">あきらめますか？</h3>
            <p>詰み状態など、どうしても進めない場合に使用します。<br>残機を1つ消費してリスポーンします。</p>
            <div class="d-flex justify-content-center gap-3 mt-4">
                <button class="btn btn-danger btn-lg px-5" onclick="executeSuicide()">はい (<span id="suicide-life-calc"></span>)</button>
                <button class="btn btn-secondary btn-lg px-5" onclick="closeSuicide()">いいえ</button>
            </div>
        </div>

        <!-- Dead Panel -->
        <div id="dead-panel" class="game-panel" style="border-color: #888;">
            <h1 class="display-5 fw-bold text-secondary">YOU ARE DEAD</h1>
            <div class="d-grid gap-3 mt-4 mx-auto" style="max-width: 400px;">
                <button class="btn btn-light btn-lg fw-bold" onclick="respawnPlayer()">
                    コンティニュー <span class="ms-2 badge bg-dark text-danger" id="dead-lives-info"></span>
                </button>
                <button class="btn btn-outline-light" onclick="showMenu()"><i class="bi bi-house-door-fill"></i> メニューへ戻る</button>
            </div>
        </div>

        <!-- Level Clear -->
        <div id="clear-panel" class="game-panel" style="border-color: #00ff88;">
            <h1 class="display-4 text-success fw-bold">CLEAR!</h1>
            <div class="bg-dark p-3 rounded mb-3 border border-secondary text-start mx-auto" style="max-width: 600px;">
                <div class="mb-2 text-center" style="color: #00ffcc; font-size: 2rem; font-weight: bold;">
                    TIME: <span id="result-time">00:00.00</span>
                </div>
                <div class="small text-warning text-center mb-3 fs-5" id="new-record-msg" style="display:none;">★ NEW RECORD! ★</div>
                
                <div class="d-flex justify-content-between border-bottom border-secondary pb-2 mb-2 fs-5">
                    <span class="text-secondary">獲得コイン:</span>
                    <span class="text-warning fw-bold">+<span id="result-coins">0</span></span>
                </div>
                <div class="d-flex justify-content-between fs-5">
                    <span class="text-secondary">残機推移:</span>
                    <span class="text-light fw-bold"><span id="result-life-diff"></span></span>
                </div>
                
                <div class="mt-3 small text-secondary text-center">▼ 通ったルート ▼</div>
                <canvas id="result-map-canvas"></canvas>
            </div>
            <div class="d-grid gap-2 mx-auto" style="max-width: 500px;">
                <button class="btn btn-primary btn-lg fw-bold" onclick="nextLevel()"><i class="bi bi-play-fill"></i> 次のレベルへ</button>
                <button class="btn btn-outline-light" onclick="showMenu()"><i class="bi bi-house-door-fill"></i> メニューへ戻る</button>
            </div>
        </div>
    </div>

    <div id="mobile-controls">
        <div class="control-group">
            <div class="control-btn" id="btn-left"><i class="bi bi-caret-left-fill"></i></div>
            <div class="control-btn" id="btn-down" style="font-size: 12px;">しゃがむ</div>
            <div class="control-btn" id="btn-right"><i class="bi bi-caret-right-fill"></i></div>
        </div>
        <div class="control-group">
            <div style="display:flex; flex-direction:column; gap:10px;">
                <div class="control-btn btn-sub btn-hip" id="btn-hip">ヒップ</div>
                <div class="control-btn btn-sub btn-run" id="btn-run">走る</div>
            </div>
            <div class="control-btn btn-action btn-jump" id="btn-jump">JUMP</div>
        </div>
    </div>
</div>

<script>
/** UTILS **/
const fmt = (n) => n.toLocaleString('ja-JP');

/** SYSTEM **/
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false });
const GAME_WIDTH = 800;
const GAME_HEIGHT = 450;
const TILE_SIZE = 40;

// Data
let gameData = { lives: 10, coins: 0, maxReachedLevel: 1, history: [], bestTimes: {}, settings: { initialLives: 10 } };
let isFirstBoot = true; 

// Load Save
const saved = localStorage.getItem('panicCat_save_v15_fix_death');
if(saved) { 
    try { 
        gameData = { ...gameData, ...JSON.parse(saved) }; 
        isFirstBoot = false;
    } catch(e){} 
}
function saveData() { localStorage.setItem('panicCat_save_v15_fix_death', JSON.stringify(gameData)); }

// Themes
const THEMES = [
    { name: 'PLAIN',    bg: '#87CEEB', ground: '#654321', grass: '#32CD32', block: '#A0522D', hard: '#696969' },
    { name: 'UNDERGROUND', bg: '#000000', ground: '#0000AA', grass: '#008800', block: '#0055AA', hard: '#808080' },
    { name: 'CASTLE',   bg: '#2c2c2c', ground: '#4a4a4a', grass: '#800000', block: '#606060', hard: '#2F4F4F' },
    { name: 'ATHLETIC', bg: '#87CEEB', ground: '#CD853F', grass: '#8B4513', block: '#DEB887', hard: '#A0522D' },
    { name: 'UNDERWATER', bg: '#191970', ground: '#20B2AA', grass: '#008080', block: '#4682B4', hard: '#5F9EA0' },
    { name: 'SNOW',     bg: '#E0FFFF', ground: '#F0FFFF', grass: '#B0E0E6', block: '#ADD8E6', hard: '#708090' },
    { name: 'DESERT',   bg: '#F4A460', ground: '#D2691E', grass: '#FFD700', block: '#CD853F', hard: '#8B4513' },
    { name: 'GHOST',    bg: '#2c003e', ground: '#3e2723', grass: '#4a148c', block: '#5d4037', hard: '#1a1a1a' },
    { name: 'SKY',      bg: '#B0C4DE', ground: '#FFFFFF', grass: '#F0F8FF', block: '#FFFFFF', hard: '#A9A9A9' },
    { name: 'FOREST',   bg: '#2E8B57', ground: '#556B2F', grass: '#006400', block: '#8B4513', hard: '#004d00' },
    { name: 'VOLCANO',  bg: '#400000', ground: '#200000', grass: '#FF4500', block: '#800000', hard: '#1a0000' },
    { name: 'BEACH',    bg: '#00BFFF', ground: '#F0E68C', grass: '#FFD700', block: '#FF69B4', hard: '#CD5C5C' }
];

let currentTheme = THEMES[0];

// Constants & Tile Definitions
const GRAVITY = 0.6; const FRICTION = 0.82; const JUMP_FORCE = 12.5; 
const MOVE_SPEED = 0.8; const MAX_SPEED = 6.0;
const RUN_ACCEL = 1.2; const RUN_MAX_SPEED = 9.0;
const CROUCH_FRICTION = 0.92; const HIP_DROP_SPEED = 15;

const T = { 
    EMPTY:0, GROUND:1, BLOCK:2, HARD_BLOCK:3, SPIKE:4, POLE:5, 
    Q_BLOCK:6, HIDDEN:7, FALLING:8, FAKE:9, INVISIBLE_DEATH:10, 
    USED_BLOCK:11, FACE_BLOCK:12, CHECKPOINT:13, CHECKPOINT_ON:14, 
    COIN:15, FAKE_SPIKE:16, CEILING_SPIKE:17, HIDDEN_TRIGGER:18, 
    COIN_BLOCK:19, MULTI_COIN_BLOCK:20,
    TROLL_HIDDEN: 21, 
    FALL_TRAP: 22,    
    DELAY_FALL: 23,   
    MEGA_COIN_BLOCK: 24,
    SKY_SPAWNER: 25,   
    TRAP_COIN_BLOCK: 26,
    HIDDEN_SPIKE: 27,  
    FALLING_CLOUD: 28, 
    FAKE_STAR: 29,     
    BG_FALL_TRIGGER: 30 
};

const I = { 
    MUSHROOM:1, POISON:2, FAKE:3, ENEMY_SPAWN:4, GREY:5, FAKE_GOOD:6, FAKE_GREY:7, STAR_TRAP: 8
}; 

// Runtime
let gameState = 'MENU';
let currentLevel = 1;
let activeCheats = { flight: false, god: false, speed: false, unlock: false, infinite: false, infiniteCoins: false };
let allowNegativeLives = false;
let currentSeed = 0;
let levelStartCoins = 0; let levelStartLives = 0;
let startTime=0, elapsedTime=0, isTimerRunning=false;
let frameCount = 0;
let trail = [];
let flagMoved = false;
let laserActive = false;

// Objects
let levelMap = []; let items = []; let particles = []; let enemies = []; let debris = [];
let activeBlocks = {}; 
let goalPole = { x:0, y:0, h:0, flagY:0, isFake:false, runaway:false, speed:0, laser: false };
let player = { x:0, y:0, w:30, h:30, crouchH:18, vx:0, vy:0, grounded:false, facingRight:true, dead:false, isBig:false, invincible:0, crouching:false, jumpCount:0, isHipDropping:false, respawnX:100, respawnY:200 };
let keys = { left:false, right:false, up:false, down:false, jump:false, jumpPressed:false, run:false, hip:false, hipPressed:false };

/** INITIALIZATION **/
window.addEventListener('DOMContentLoaded', initSystem);

function initSystem() {
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    
    const range = document.getElementById('lives-range');
    range.value = gameData.settings.initialLives; 
    document.getElementById('lives-val').innerText = range.value;
    
    range.addEventListener('input', e => {
        const val = parseInt(e.target.value);
        gameData.settings.initialLives = val;
        document.getElementById('lives-val').innerText = val;
    });

    if (isFirstBoot) {
        document.getElementById('initial-lives-section').style.display = 'block';
    } else {
        document.getElementById('initial-lives-section').style.display = 'none';
    }

    updateMenuDisplay();

    ['flight', 'god', 'speed', 'infinite', 'unlock', 'inf-coin'].forEach(id => {
        const cid = id === 'inf-coin' ? 'infiniteCoins' : id;
        document.getElementById(`cheat-${id}`).addEventListener('change', e => {
            activeCheats[cid] = e.target.checked;
            updateCheatStatus();
            if(id==='unlock') generateLevelGrid();
            updateHUD();
        });
    });

    if('ontouchstart' in window || navigator.maxTouchPoints > 0) {
        document.getElementById('mobile-controls').style.display = 'flex';
        bindTouch('btn-left', 'left'); bindTouch('btn-right', 'right');
        bindTouch('btn-down', 'down'); bindTouch('btn-jump', 'jump');
        bindTouch('btn-run', 'run'); bindTouch('btn-hip', 'hip');
    }
    
    requestAnimationFrame(gameLoop);
}

function updateMenuDisplay() {
    document.getElementById('max-reached-display').innerText = "到達: Lv." + fmt(gameData.maxReachedLevel);
    document.getElementById('cont-level-display').innerText = fmt(gameData.maxReachedLevel);
}

/** LEVEL GRID GENERATOR **/
function showLevelSelect() {
    generateLevelGrid();
    showPanel('level-select-panel');
}

function generateLevelGrid() {
    const container = document.getElementById('level-grid-container');
    container.innerHTML = '';
    
    const max = 1000;
    const unlocked = activeCheats.unlock ? 1000 : gameData.maxReachedLevel;
    
    const fragment = document.createDocumentFragment();
    
    for (let i = 1; i <= max; i++) {
        const btn = document.createElement('button');
        btn.className = 'btn level-btn m-0';
        
        if (i <= unlocked) {
            btn.innerText = i;
            btn.classList.add('btn-outline-warning');
            btn.onclick = () => startGame(i);
        } else {
            btn.innerHTML = `<i class="bi bi-lock-fill" style="font-size:1.2rem;"></i><div style="font-size:0.6rem; opacity:0.6;">${i}</div>`;
            btn.classList.add('btn-outline-secondary', 'disabled');
            btn.style.opacity = '0.5';
        }
        
        fragment.appendChild(btn);
    }
    container.appendChild(fragment);

    setTimeout(() => {
        const target = container.children[unlocked - 1];
        if(target) target.scrollIntoView({ block: 'center' });
    }, 100);
}

function bindTouch(id, key) {
    const el = document.getElementById(id);
    el.addEventListener('touchstart', e => { 
        e.preventDefault(); 
        if(!canControl()) return; 
        keys[key]=true; el.classList.add('pressed'); 
        if(key==='jump') keys.jumpPressed=true; 
        if(key==='hip') keys.hipPressed=true; 
    });
    el.addEventListener('touchend', e => { 
        e.preventDefault(); 
        keys[key]=false; el.classList.remove('pressed'); 
    });
}

function resizeCanvas() {
    const w = document.getElementById('game-wrapper');
    const aspect = GAME_WIDTH/GAME_HEIGHT;
    let dw = w.clientWidth, dh = w.clientHeight;
    if (dw/dh > aspect) dw = dh*aspect; else dh = dw/aspect;
    const dpr = window.devicePixelRatio || 1;
    canvas.width = dw*dpr; canvas.height = dh*dpr;
    canvas.style.width = `${dw}px`; canvas.style.height = `${dh}px`;
    ctx.scale(dpr * (dw/GAME_WIDTH), dpr * (dh/GAME_HEIGHT));
    
    ['result-map-canvas', 'history-route-canvas'].forEach(id => {
        const c = document.getElementById(id);
        if(c) { c.width = c.clientWidth*dpr; c.height = c.clientHeight*dpr; }
    });
}

function updateCheatStatus() {
    document.getElementById('cheat-status').style.display = Object.values(activeCheats).some(v=>v) ? 'block' : 'none';
}

function showPanel(id) {
    document.querySelectorAll('.game-panel').forEach(p => p.classList.remove('active'));
    const pauseBtn = document.getElementById('pause-container');
    if (!id && gameState === 'PLAYING') {
        pauseBtn.style.display = 'block';
    } else {
        pauseBtn.style.display = 'none';
    }

    const suicideBtn = document.getElementById('suicide-btn');
    if (gameState === 'PLAYING' && !id) {
        suicideBtn.classList.remove('disabled');
    } else {
        suicideBtn.classList.add('disabled');
    }

    if(id) {
        document.getElementById(id).classList.add('active');
        if(id==='clear-panel') setTimeout(drawResultMap, 100);
    }
}
function showCheats() { showPanel('cheat-panel'); }
function showHelp() { showPanel('help-panel'); }

/** SHOP **/
const SHOP_ITEMS = [
    { type: 'life', n: 1, cost: 100, discount: 0 },
    { type: 'life', n: 5, cost: 475, discount: 5, saved: 25 },
    { type: 'life', n: 10, cost: 900, discount: 10, saved: 100 },
    { type: 'life', n: 25, cost: 2125, discount: 15, saved: 375 },
    { type: 'life', n: 50, cost: 4000, discount: 20, saved: 1000 },
    { type: 'life', n: 100, cost: 7500, discount: 25, saved: 2500 },
    { type: 'skip', n: 1, cost: 10000, discount: 0 },
    { type: 'skip', n: 5, cost: 45000, discount: 10, saved: 5000 },
    { type: 'skip', n: 10, cost: 75000, discount: 25, saved: 25000 }
];

function showShop() {
    const list = document.getElementById('shop-list');
    list.innerHTML = '';
    const currentCoins = activeCheats.infiniteCoins ? "∞" : fmt(gameData.coins);
    document.getElementById('shop-coins').innerText = currentCoins;
    
    let lastType = null;

    SHOP_ITEMS.forEach(item => {
        if(lastType !== item.type) {
            const title = document.createElement('div');
            title.className = 'shop-section-title';
            title.innerHTML = item.type === 'life' 
                ? '<i class="bi bi-heart-fill text-danger"></i> 残機購入' 
                : '<i class="bi bi-fast-forward-fill text-info"></i> レベルスキップ';
            list.appendChild(title);
            lastType = item.type;
        }

        const div = document.createElement('div');
        div.className = 'shop-item';
        let originalPrice = Math.round(item.cost / ((100 - item.discount)/100));
        let priceHtml = item.discount > 0 
            ? `<span class="old-price">${fmt(originalPrice)}</span><span class="new-price">${fmt(item.cost)}</span>`
            : `<span class="new-price">${fmt(item.cost)}</span>`;
        let badge = item.discount > 0 ? `<span class="discount-badge">${item.discount}% OFF</span>` : '';
        let savedText = item.saved ? `<span class="saved-text">${fmt(item.saved)}コインお得</span>` : '';
        const canBuy = activeCheats.infiniteCoins || gameData.coins >= item.cost;
        const afterCoin = activeCheats.infiniteCoins ? "∞" : fmt(gameData.coins - item.cost);
        const displayCoin = activeCheats.infiniteCoins ? "∞" : fmt(gameData.coins);

        let itemName = item.type === 'life' 
            ? `<i class="bi bi-heart-fill text-danger"></i> +${fmt(item.n)}`
            : `<i class="bi bi-fast-forward-fill text-info"></i> +${fmt(item.n)} LV`;

        const func = item.type === 'life' 
            ? `buyLives(${item.n}, ${item.cost})`
            : `buySkip(${item.n}, ${item.cost})`;

        div.innerHTML = `
            <div><span class="fw-bold text-light fs-5">${itemName}</span></div>
            <div class="price-container">
                <div>${priceHtml} <i class="bi bi-circle-fill text-warning small"></i>${badge}</div>
                ${savedText}
                <button class="btn btn-sm btn-primary mt-1 fw-bold px-3" ${canBuy?'':'disabled'} onclick="${func}">購入</button>
                <div class="coin-calc">
                    ${displayCoin} <i class="bi bi-arrow-right-short"></i> <span class="${canBuy?'text-light':'text-danger'}">${afterCoin}</span>
                </div>
            </div>`;
        list.appendChild(div);
    });
    showPanel('shop-panel');
}

function buyLives(n, cost) {
    if(gameData.coins >= cost || activeCheats.infiniteCoins) {
        if(!activeCheats.infiniteCoins) gameData.coins -= cost;
        gameData.lives += n;
        saveData();
        showShop();
        updateHUD();
    }
}

function buySkip(n, cost) {
    if(gameData.coins >= cost || activeCheats.infiniteCoins) {
        if(confirm(`${n}レベルスキップを購入しますか？`)) {
            if(!activeCheats.infiniteCoins) gameData.coins -= cost;
            gameData.maxReachedLevel += n;
            
            if(gameState === 'PLAYING' || gameState === 'PAUSED') {
                currentLevel += n;
                saveData();
                resetLevel(true);
                showPanel(null);
                gameState = 'PLAYING';
                startTimer();
            } else {
                saveData();
                showShop();
                updateMenuDisplay();
            }
            updateHUD();
        }
    }
}

function setCheatCoins() {
    const val = parseInt(document.getElementById('cheat-coin-val').value);
    if(!isNaN(val) && val >= 0) { gameData.coins = val; saveData(); updateHUD(); alert(`コインを ${val} に設定しました`); }
}
function setCheatLives() {
    const val = parseInt(document.getElementById('cheat-life-val').value);
    if(!isNaN(val) && val >= 0) { gameData.lives = val; saveData(); updateHUD(); alert(`残機を ${val} に設定しました`); }
}

function showHistory() {
    const tbody = document.getElementById('history-table-body');
    tbody.innerHTML = '';
    [...gameData.history].reverse().forEach((h, idx) => {
        const row = document.createElement('tr');
        row.innerHTML = `
            <td>${h.date}</td><td>${fmt(h.level)}</td><td>${h.time}</td><td>${fmt(h.coins)}</td>
            <td class="fw-bold text-danger">${h.lives !== undefined ? fmt(h.lives) : '-'}</td>
            <td><button class="btn btn-sm btn-outline-info" onclick="viewHistoryRoute(${gameData.history.length - 1 - idx})"><i class="bi bi-map"></i></button></td>
        `;
        tbody.appendChild(row);
    });
    showPanel('history-panel');
}

function viewHistoryRoute(index) {
    const h = gameData.history[index];
    if(!h) return;
    document.getElementById('route-view-level').innerText = h.level;
    showPanel('route-view-panel');
    const c = document.getElementById('history-route-canvas');
    generateWorld(h.level); 
    drawMapOnCanvas(c.getContext('2d'), false, h.trail || []);
}

/** LEVEL UTILS **/
function copySeed() { navigator.clipboard.writeText(currentSeed).then(()=>alert(`SEED: ${currentSeed} コピーしました`)); }

function showMenu() { 
    gameState = 'MENU'; 
    isTimerRunning = false; 
    startTime = 0; elapsedTime = 0;
    updateMenuDisplay();
    showPanel('menu-panel'); 
}

function startGame(lv) { 
    if(isFirstBoot) {
        gameData.lives = gameData.settings.initialLives;
        isFirstBoot = false;
        document.getElementById('initial-lives-section').style.display = 'none';
        saveData();
    }
    currentLevel = lv; 
    if(gameState==='MENU' && gameData.lives <= 0) {
        if(!confirm("残機がありません。残機マイナス（借金モード）で開始しますか？")) {
             return;
        }
        allowNegativeLives = true;
    }
    levelStartCoins=gameData.coins; levelStartLives=gameData.lives; 
    player.respawnX=100; player.respawnY=200; 
    
    resetLevel(true); 
    gameState='PLAYING'; 
    showPanel(null); 
    startTimer(); 
}

function retryGame() { 
    if(gameData.lives <= 0 && !allowNegativeLives && !activeCheats.god) return; 
    allowNegativeLives=false; player.respawnX=100; player.respawnY=200; 
    resetLevel(true); 
    gameState='PLAYING'; 
    showPanel(null); 
    startTimer(); 
}

function resetAllData() {
    if(confirm("本当に全てのデータを初期化しますか？")) {
        localStorage.removeItem('panicCat_save_v15_fix_death');
        location.reload();
    }
}

function startTimer() { startTime = Date.now(); elapsedTime = 0; isTimerRunning = true; trail = []; }
function nextLevel() { 
    currentLevel++; levelStartCoins=gameData.coins; levelStartLives=gameData.lives; player.respawnX=100; player.respawnY=200; 
    resetLevel(true); 
    gameState='PLAYING'; 
    showPanel(null); 
    startTimer(); 
}

/** PAUSE **/
function togglePause() {
    if (gameState === 'MENU' || gameState === 'CLEARED' || gameState === 'GAMEOVER' || player.dead) return;
    if(gameState === 'PLAYING') {
        gameState = 'PAUSED'; showPanel('pause-panel'); isTimerRunning = false;
    } else if (gameState === 'PAUSED') {
        gameState = 'PLAYING'; showPanel(null); isTimerRunning = true; startTime = Date.now() - elapsedTime;
    }
}
function canControl() { return gameState === 'PLAYING' && !player.dead; }

/** GAME LOGIC & LEVEL GENERATION **/
function resetLevel(fullReset) {
    enemies = []; debris = [];
    generateWorld(currentLevel);
    player.x=player.respawnX; player.y=player.respawnY; player.vx=0; player.vy=0; 
    player.dead=false; player.grounded=false; player.isBig=false; player.invincible=0; 
    player.crouching=false; player.jumpCount=0; player.isHipDropping=false;
    items=[]; particles=[]; 
    keys.jumpPressed=false; keys.hipPressed=false; 
    keys.left=false; keys.right=false; keys.jump=false; keys.down=false;
    goalPole.flagY=0; goalPole.speed=0; goalPole.laser=false;
    flagMoved = false; laserActive=false;
    
    // Clear safe zone around respawn
    clearSafeZone();
}

function clearSafeZone() {
    // Remove enemies near player respawn to prevent spawn camping
    enemies = enemies.filter(e => {
        const dx = e.x - player.x;
        const dy = e.y - player.y;
        return Math.sqrt(dx*dx + dy*dy) > 300;
    });
}

function generateWorld(lv) {
    currentSeed = lv * 12345; 
    document.getElementById('menu-seed-val').innerText = currentSeed;
    let seed = currentSeed; const rand = () => { seed = (seed * 9301 + 49297) % 233280; return seed / 233280; };
    const randInt = (min, max) => Math.floor(rand() * (max - min + 1)) + min;
    
    // Choose Theme
    const themeIdx = (lv - 1) % THEMES.length;
    currentTheme = THEMES[themeIdx];
    canvas.style.backgroundColor = currentTheme.bg;

    const difficulty = Math.min(1, (lv - 1) / 500);
    const width = 200 + (lv * 10); 
    const height = 15; 
    const gY = 11;
    
    levelMap = Array(height).fill().map(() => Array(width).fill(T.EMPTY));
    activeBlocks = {}; 

    // Basic Ground
    let cx = 0;
    let justMadeHole = false;
    
    while(cx < width) {
        // Start area safe zone
        if (cx < 15) {
            for(let y=gY; y<height; y++) levelMap[y][cx] = T.GROUND;
            cx++;
            continue;
        }
        // End area
        if (cx > width - 20) {
            for(let y=gY; y<height; y++) levelMap[y][cx] = T.GROUND;
            cx++;
            continue;
        }

        // Pit
        let pitChance = 0.1 + (difficulty * 0.2);
        if (!justMadeHole && rand() < pitChance) {
            let holeLen = randInt(2, 3 + Math.floor(difficulty * 2));
            if (holeLen > 6) holeLen = 6; 
            
            // Kaizo Gap: Invisible ceiling over pit (Logic fixed to cover wide gaps)
            if (rand() < 0.4 + (difficulty * 0.5)) {
                for(let k=0; k<holeLen+2; k++) { // Cover entire gap + margins
                    if (gY-4 >= 0) levelMap[gY-4][cx-1+k] = T.TROLL_HIDDEN;
                }
            }
            // Invisible death ONLY inside pit (bottom row)
            if (difficulty > 0.5 && rand() < 0.3) {
                 for(let k=0; k<holeLen; k++) levelMap[height-1][cx+k] = T.INVISIBLE_DEATH;
            }
            cx += holeLen;
            justMadeHole = true;
        } else {
            // Ground
            let len = randInt(2, 6);
            for(let k=0; k<len; k++) {
                let tile = T.GROUND;
                // Fall traps
                if (rand() < 0.05 + (difficulty * 0.25)) {
                    tile = (rand() < 0.5) ? T.FALL_TRAP : T.DELAY_FALL;
                }
                // Hidden Spike (New) - kept but ensure it's visible as ground first
                if (rand() < 0.03 + (difficulty * 0.1)) {
                    tile = T.HIDDEN_SPIKE;
                }
                
                levelMap[gY][cx+k] = tile;
                if (tile === T.GROUND || tile === T.HIDDEN_SPIKE) {
                    for(let y=gY+1; y<height; y++) levelMap[y][cx+k] = T.GROUND;
                }
                
                if (rand() < 0.3) {
                    levelMap[gY-1][cx+k] = T.COIN;
                }
                // Background Fall Trigger
                if(rand() < 0.02) levelMap[gY-3][cx+k] = T.BG_FALL_TRIGGER;

                if (difficulty > 0.1 && rand() < 0.08 + (difficulty * 0.15)) {
                    levelMap[gY-5][cx+k] = T.SKY_SPAWNER;
                }
            }
            cx += len;
            justMadeHole = false;
        }
    }

    // Objects
    cx = 15;
    while (cx < width - 20) {
        if (levelMap[gY][cx] === T.EMPTY) { cx++; continue; }
        
        // Increased Pattern variety for Syobon/Mario feel
        const pat = randInt(0, 20); 
        
        if (cx > width/2 && !levelMap.flat().includes(T.CHECKPOINT)) {
             levelMap[gY-1][cx] = T.CHECKPOINT;
             if (difficulty > 0.3 && rand() < 0.4) levelMap[gY][cx] = T.DELAY_FALL;
        }

        // Increased Enemy Spawn Rate
        if (rand() < 0.25 + (difficulty * 0.2)) {
             spawnEnemy((cx)*TILE_SIZE, (gY-1)*TILE_SIZE);
        }

        if (pat === 0) { // Standard Blocks
            levelMap[gY-3][cx] = T.BLOCK; levelMap[gY-3][cx+1] = T.BLOCK; levelMap[gY-3][cx+2] = T.BLOCK;
            let mid = levelMap[gY-3][cx+1];
            let r = rand();
            if(r < 0.2) mid = T.COIN_BLOCK;
            else if(r < 0.3) mid = T.MULTI_COIN_BLOCK;
            else if(r < 0.35) mid = T.MEGA_COIN_BLOCK;
            else if(r < 0.38) mid = T.TRAP_COIN_BLOCK;
            levelMap[gY-3][cx+1] = mid;

            if (rand() < 0.5) levelMap[gY-3][cx+1] = T.FALLING;
            levelMap[gY-6][cx+1] = T.COIN;
            levelMap[gY-7][cx+1] = T.TROLL_HIDDEN;
        }
        else if (pat === 1) { // Pipe-like structure
            levelMap[gY-1][cx] = T.HARD_BLOCK; levelMap[gY-2][cx] = T.HARD_BLOCK;
            if (difficulty > 0.2 && rand() < 0.4) {
                levelMap[gY-1][cx-1] = T.TROLL_HIDDEN;
            }
        }
        else if (pat === 2) { // Question Block Trap
            levelMap[gY-4][cx] = T.Q_BLOCK;
        }
        else if (pat === 3) { // Staircase
            for(let i=0; i<4; i++) {
                let tx = cx+i; let ty = gY-1-i;
                if (tx < width) {
                    levelMap[ty][tx] = T.BLOCK;
                    if (i===3) levelMap[ty][tx] = T.FALL_TRAP;
                }
            }
        }
        else if (pat === 4) { // Ceiling Spikes
            levelMap[gY-4][cx] = T.CEILING_SPIKE;
            // REMOVED: INVISIBLE DEATH ON GROUND (Fixes dying before hole)
        }
        else if (pat === 5) { // Invisible bridge
            if (levelMap[gY][cx+1] === T.EMPTY && levelMap[gY][cx+2] === T.EMPTY) {
                if (rand() < 0.5) {
                    levelMap[gY][cx+1] = T.TROLL_HIDDEN; 
                    levelMap[gY][cx+2] = T.TROLL_HIDDEN;
                }
            }
        }
        else if (pat === 6) { // Kaizo Trap (Fixed Logic)
            if(cx + 6 < width) {
                levelMap[gY][cx+1] = T.EMPTY; levelMap[gY][cx+2] = T.EMPTY; levelMap[gY][cx+3] = T.EMPTY;
                levelMap[gY][cx+4] = T.GROUND;
                // Cover the jump arc
                levelMap[gY-4][cx+2] = T.TROLL_HIDDEN;
                levelMap[gY-4][cx+3] = T.TROLL_HIDDEN;
            }
        }
        else if (pat === 7) { // Exit Seal Trap
             if(cx + 3 < width) {
                levelMap[gY][cx] = T.EMPTY;
                levelMap[gY][cx+1] = T.EMPTY; 
                levelMap[gY][cx+2] = T.EMPTY; 
                levelMap[gY+2][cx] = T.HARD_BLOCK;
                levelMap[gY+2][cx+1] = T.HARD_BLOCK;
                levelMap[gY+2][cx+2] = T.HARD_BLOCK;
                levelMap[gY+1][cx+1] = T.COIN;
                levelMap[gY-1][cx] = T.TROLL_HIDDEN;
                levelMap[gY-1][cx+1] = T.TROLL_HIDDEN;
                levelMap[gY-1][cx+2] = T.TROLL_HIDDEN;
             }
        }
        else if (pat === 8) { // Isolated Mega Block
            levelMap[gY-3][cx] = T.MEGA_COIN_BLOCK;
            if(rand() < 0.3) levelMap[gY-2][cx] = T.TROLL_HIDDEN;
        }
        else if (pat === 9) { // Falling Clouds
            for(let i=0; i<3; i++) levelMap[gY-4][cx+i] = T.FALLING_CLOUD;
        }
        else if (pat === 10) { // Fake Star
            levelMap[gY-3][cx] = T.BLOCK;
            spawnItem(cx*TILE_SIZE, (gY-4)*TILE_SIZE, I.FAKE_STAR);
        }
        else if (pat === 11) { // Floor Spikes (Hidden)
            levelMap[gY][cx] = T.HIDDEN_SPIKE;
            levelMap[gY][cx+1] = T.HIDDEN_SPIKE;
        }
        
        cx += 4;
    }

    // Goal Area
    goalPole = { x: (width-10)*TILE_SIZE + 15, y: (gY-8)*TILE_SIZE, h: 8*TILE_SIZE, flagY: 0, isFake: false, runaway: false, speed: 0, laser: false };
    levelMap[gY-1][width-10] = T.POLE;
    
    // Fake/Runaway/Laser Pole
    const r = rand();
    if (difficulty > 0.1 && r < 0.2) goalPole.runaway = true;
    else if (difficulty > 0.3 && r < 0.4) goalPole.laser = true;
    
    if(player.respawnX > 500) { 
        for(let y=0; y<height; y++) for(let x=0; x<width; x++) if(levelMap[y][x]===T.CHECKPOINT) levelMap[y][x]=T.CHECKPOINT_ON; 
    }
}

function gameLoop() {
    update(); draw();
    if(gameState === 'PLAYING' || gameState === 'PAUSED' || gameState === 'CLEARED') { 
        updateHUD(); 
    }
    requestAnimationFrame(gameLoop);
}

function update() {
    if(gameState === 'GOAL_ANIM') { updateGoalAnim(); return; }
    if(gameState !== 'PLAYING') return;
    if(player.dead) return;

    // Controls
    if((keys.down || keys.hip) && !player.grounded && !player.crouching && keys.hipPressed) { 
        player.vy = HIP_DROP_SPEED; 
        player.isHipDropping = true; 
        keys.hipPressed = false; 
    }

    if(activeCheats.flight && (keys.jump || keys.up)) { player.vy = -5; player.grounded = false; }
    else if(activeCheats.flight && keys.down) player.vy = 5;
    else {
        if(keys.jumpPressed) {
            if(player.grounded) { 
                player.vy = -JUMP_FORCE; 
                player.grounded = false; 
                player.jumpCount = 1; 
                spawnParticles(player.x, player.y+20, '#FFF'); 
            } else if (player.jumpCount < 2 || activeCheats.infinite) { 
                player.vy = -JUMP_FORCE * 0.9; 
                player.jumpCount++; 
                spawnParticles(player.x, player.y+20, '#FFF'); 
            }
            keys.jumpPressed = false; 
        }
        player.vy += activeCheats.flight ? 0 : GRAVITY;
    }

    let acc = keys.run ? RUN_ACCEL : MOVE_SPEED;
    let cap = keys.run ? RUN_MAX_SPEED : MAX_SPEED;
    if(activeCheats.speed) { acc *= 3; cap *= 2.5; }

    if(keys.left) { player.vx -= acc; player.facingRight = false; }
    if(keys.right) { player.vx += acc; player.facingRight = true; }

    let fric = player.crouching ? CROUCH_FRICTION : FRICTION;
    if(currentTheme.name === 'SNOW') fric = 0.96; // Ice physics
    if(currentTheme.name === 'UNDERWATER') { player.vy *= 0.8; if(keys.jump) player.vy -= 0.5; } // Underwater feeling

    if(keys.down && player.grounded && !activeCheats.flight) { player.crouching = true; player.vx *= fric; }
    else { player.crouching = false; player.vx *= fric; }

    if(player.vx > cap) player.vx = cap; if(player.vx < -cap) player.vx = -cap;
    if(Math.abs(player.vx) < 0.1) player.vx = 0;

    let steps = Math.ceil(Math.max(Math.abs(player.vx), Math.abs(player.vy)) / (TILE_SIZE * 0.25));
    let svx = player.vx/steps; let svy = player.vy/steps;
    
    for(let i=0; i<steps; i++) { 
        player.x += svx; checkCollisionX(player); 
        player.y += svy; checkCollisionY(player); 
    }

    // Goal Traps
    let dist = Math.abs(player.x - goalPole.x);
    if(goalPole.runaway) {
        if(!flagMoved && dist < 200) {
            goalPole.speed = 4.5; 
            flagMoved = true;
        }
        if(flagMoved) {
            goalPole.x += goalPole.speed;
            if(dist > 600) goalPole.speed = 0;
            else goalPole.speed = 4.5;
        }
    }
    if(goalPole.laser && dist < 300 && !laserActive) {
        laserActive = true;
        setTimeout(() => {
             // Laser fires
             if(Math.abs(player.x - goalPole.x) < 400 && player.y > goalPole.y) die();
             laserActive = false;
        }, 800);
    }

    if(player.x+player.w > goalPole.x && player.x < goalPole.x+10 && player.y < goalPole.y+goalPole.h && player.y+player.h > goalPole.y) {
        startGoalAnim();
    }
    
    // Fall Death (Ensure death)
    if(player.y > GAME_HEIGHT + 60) die();

    if(player.invincible > 0) player.invincible--;
    
    updateItems();
    updateEnemies();
    updateDebris();
    
    if(frameCount%5===0 && !player.dead) trail.push({x: player.x+player.w/2, y: player.y+player.h/2});
    frameCount++;
}

function spawnEnemy(x, y) {
    let diff = Math.min(1, currentLevel/500);
    let spd = -1.5 - (diff * 2.0);
    enemies.push({ x: x, y: y, w: 30, h: 30, vx: spd, vy: 0, dead: false });
}

function spawnDebris(x) {
    debris.push({ x: x, y: -40, w: 30, h: 30, vx: 0, vy: 2, active: true });
}

function updateDebris() {
    for(let i=debris.length-1; i>=0; i--) {
        let d = debris[i];
        d.vy += 0.2; d.y += d.vy;
        if(d.y > GAME_HEIGHT) { debris.splice(i, 1); continue; }
        if(intersect(player, d)) { hitDamage(); debris.splice(i, 1); }
    }
}

function updateEnemies() {
    for (let i = enemies.length - 1; i >= 0; i--) {
        let e = enemies[i];
        if (e.dead) { enemies.splice(i, 1); continue; }
        e.vy += GRAVITY; e.x += e.vx;
        
        let startX = Math.floor(e.x/TILE_SIZE), endX = Math.floor((e.x+e.w-0.1)/TILE_SIZE);
        let startY = Math.floor(e.y/TILE_SIZE), endY = Math.floor((e.y+e.h-0.1)/TILE_SIZE);
        let colX = false;
        for(let y=startY; y<=endY; y++) for(let x=startX; x<=endX; x++) if(isSolid(getTile(x, y))) colX = true;
        if(colX) { e.vx *= -1; e.x += e.vx * 2; }

        e.y += e.vy;
        startX = Math.floor(e.x/TILE_SIZE); endX = Math.floor((e.x+e.w-0.1)/TILE_SIZE);
        startY = Math.floor(e.y/TILE_SIZE); endY = Math.floor((e.y+e.h-0.1)/TILE_SIZE);
        for(let y=startY; y<=endY; y++) for(let x=startX; x<=endX; x++) {
            if(isSolid(getTile(x, y)) && e.vy > 0) { e.y = y * TILE_SIZE - e.h; e.vy = 0; }
        }
        if (e.y > GAME_HEIGHT + 100) { enemies.splice(i, 1); continue; }
        if (intersect(player, e) && !player.dead) {
            if (player.vy > 0 && player.y + player.h < e.y + e.h / 2 + 10) {
                e.dead = true; player.vy = -8; spawnParticles(e.x, e.y, '#8B4513');
                if(!activeCheats.infiniteCoins) gameData.coins += 5;
            } else { hitDamage(); }
        }
    }
}

function startGoalAnim() { gameState = 'GOAL_ANIM'; player.vx = 0; player.vy = 0; player.x = goalPole.x - 10; isTimerRunning = false; }
function updateGoalAnim() { 
    if(player.y < goalPole.y + goalPole.h - player.h) player.y += 4; 
    else { 
        if(goalPole.flagY < goalPole.h - 40) goalPole.flagY += 4; 
        else if(gameState !== 'CLEARED') levelClear(); 
    } 
}

function checkCollisionY(obj) {
    const offsetY = obj.crouching ? (obj.h - obj.crouchH) : 0;
    obj.grounded = false;
    const startX = Math.floor(obj.x / TILE_SIZE);
    const endX = Math.floor((obj.x + obj.w - 0.1) / TILE_SIZE);
    const startY = Math.floor((obj.y + offsetY) / TILE_SIZE);
    const endY = Math.floor((obj.y + obj.h - 0.1) / TILE_SIZE);

    for (let y = startY; y <= endY; y++) {
        for (let x = startX; x <= endX; x++) {
            const t = getTile(x, y);
            if(obj===player) {
                if(t===T.COIN) { levelMap[y][x] = T.EMPTY; if(!activeCheats.infiniteCoins) gameData.coins++; saveData(); spawnParticles(x*TILE_SIZE+20,y*TILE_SIZE+20,'#FFD700'); }
                if(t===T.CHECKPOINT) { levelMap[y][x] = T.CHECKPOINT_ON; player.respawnX = x*TILE_SIZE; player.respawnY = y*TILE_SIZE; spawnParticles(x*TILE_SIZE+20, y*TILE_SIZE, '#00FF00'); }
                if(t===T.SPIKE) { if(intersect(obj, {x:x*TILE_SIZE+10, y:y*TILE_SIZE+10, w:20, h:20})) hitDamage(); }
                // Ceiling Spike Logic Fixed: Die on jump hitting it
                if(t===T.CEILING_SPIKE) { 
                    if(obj.vy < 0 && intersect(obj, {x:x*TILE_SIZE+5, y:y*TILE_SIZE+10, w:30, h:30})) die();
                    else if(intersect(obj, {x:x*TILE_SIZE+10, y:y*TILE_SIZE+10, w:20, h:20})) hitDamage();
                }
                if(t===T.INVISIBLE_DEATH) die();
                if(obj.vy<0 && obj.y<(y+1)*TILE_SIZE && obj.y>y*TILE_SIZE) handleHeadBump(x,y,t);
                if(t===T.HIDDEN_TRIGGER || t===T.SKY_SPAWNER || t===T.BG_FALL_TRIGGER) {
                    if (t===T.SKY_SPAWNER) { spawnDebris(player.x); levelMap[y][x] = T.EMPTY; }
                    else if(t===T.BG_FALL_TRIGGER) { canvas.style.transform = "rotate(2deg)"; setTimeout(()=>canvas.style.transform="rotate(0)", 500); levelMap[y][x]=T.EMPTY; }
                    else { levelMap[y][x] = T.HARD_BLOCK; }
                }
                if(t===T.HIDDEN_SPIKE) { levelMap[y][x] = T.SPIKE; hitDamage(); }
            }
            if (isSolid(t)) {
                if (obj.vy >= 0) {
                    if (obj.y + obj.h <= (y * TILE_SIZE) + (obj.vy + 10)) {
                        obj.y = y * TILE_SIZE - obj.h; obj.vy = 0; obj.grounded = true; obj.jumpCount = 0;
                        if((t===T.Q_BLOCK || t===T.COIN_BLOCK || t===T.MULTI_COIN_BLOCK || t===T.MEGA_COIN_BLOCK || t===T.TRAP_COIN_BLOCK || t===T.BLOCK) && player.isHipDropping) {
                             handleHeadBump(x,y,t); player.vy = -6;
                        }
                        if(t===T.FALLING || t===T.FALL_TRAP || t===T.FALLING_CLOUD) {
                             setTimeout(()=>{ 
                                 if(levelMap[y][x]===T.FALLING || levelMap[y][x]===T.FALL_TRAP || levelMap[y][x]===T.FALLING_CLOUD){
                                     levelMap[y][x]=T.EMPTY; spawnParticles(x*TILE_SIZE+20,y*TILE_SIZE+20,'#aaa');
                                 } 
                             }, t===T.FALL_TRAP ? 50 : (t===T.FALLING_CLOUD ? 300 : 150));
                        }
                        if(t===T.DELAY_FALL && obj===player) {
                            setTimeout(()=>{ if(levelMap[y][x]===T.DELAY_FALL){ levelMap[y][x]=T.FALLING; } }, 400);
                        }

                        player.isHipDropping = false;
                    }
                } else if (obj.vy < 0) {
                     if (obj.y >= (y + 1) * TILE_SIZE - 10) { obj.y = (y + 1) * TILE_SIZE; obj.vy = 0; }
                }
            }
        }
    }
}

function checkCollisionX(obj) {
    const offsetY = obj.crouching ? (obj.h - obj.crouchH) : 0;
    const startX = Math.floor(obj.x / TILE_SIZE);
    const endX = Math.floor((obj.x + obj.w - 0.1) / TILE_SIZE);
    const startY = Math.floor((obj.y + offsetY) / TILE_SIZE);
    const endY = Math.floor((obj.y + obj.h - 0.1) / TILE_SIZE);

    for (let y = startY; y <= endY; y++) {
        for (let x = startX; x <= endX; x++) {
            const t = getTile(x, y);
            if(t===T.COIN && obj===player) { levelMap[y][x] = T.EMPTY; if(!activeCheats.infiniteCoins) gameData.coins++; saveData(); spawnParticles(x*TILE_SIZE+20,y*TILE_SIZE+20,'#FFD700'); }
            if(obj===player && t===T.CHECKPOINT) { levelMap[y][x] = T.CHECKPOINT_ON; player.respawnX = x*TILE_SIZE; player.respawnY = y*TILE_SIZE; spawnParticles(x*TILE_SIZE+20, y*TILE_SIZE, '#00FF00'); }
            if(t===T.INVISIBLE_DEATH && obj===player) die();
            if(t===T.HIDDEN_TRIGGER || t===T.SKY_SPAWNER) {
                 if(t===T.SKY_SPAWNER) { spawnDebris(player.x); levelMap[y][x] = T.EMPTY; }
                 else levelMap[y][x] = T.HARD_BLOCK;
            }
            if(t===T.HIDDEN_SPIKE && obj===player) { levelMap[y][x] = T.SPIKE; hitDamage(); }
            
            if (isSolid(t)) {
                if (obj.vx > 0) { obj.x = x * TILE_SIZE - obj.w - 0.01; } else if (obj.vx < 0) { obj.x = (x + 1) * TILE_SIZE + 0.01; }
                obj.vx = 0;
            }
        }
    }
}

function handleHeadBump(x, y, t) {
    if(t===T.Q_BLOCK) {
        levelMap[y][x] = T.USED_BLOCK; 
        const rnd = Math.random();
        let item = I.MUSHROOM;
        if(rnd < 0.2) item = I.POISON;
        else if(rnd < 0.3) item = I.GREY;
        else if(rnd < 0.4) item = I.FAKE_GOOD;
        else if(rnd < 0.5) item = I.FAKE_GREY;
        else if(rnd < 0.6) item = I.ENEMY_SPAWN;
        else if(rnd < 0.7) item = I.FAKE_STAR;

        spawnItem(x*TILE_SIZE, y*TILE_SIZE-30, item); 
    } else if(t===T.COIN_BLOCK) {
        levelMap[y][x] = T.USED_BLOCK; if(!activeCheats.infiniteCoins) gameData.coins++; saveData(); spawnParticles(x*TILE_SIZE+20, y*TILE_SIZE-20, '#FFD700');
    } else if(t===T.MULTI_COIN_BLOCK || t===T.MEGA_COIN_BLOCK) {
        // Multi/Mega Coin Logic
        const key = `${currentLevel}_${x}_${y}`;
        const limit = (t===T.MEGA_COIN_BLOCK) ? 25 : 10;
        
        if(!activeBlocks[key]) activeBlocks[key] = limit;
        activeBlocks[key]--;
        
        if(!activeCheats.infiniteCoins) gameData.coins++; 
        saveData(); 
        spawnParticles(x*TILE_SIZE+20, y*TILE_SIZE-20, '#FFD700');
        
        if(activeBlocks[key] <= 0) levelMap[y][x] = T.USED_BLOCK;
    } else if(t===T.TRAP_COIN_BLOCK) {
        levelMap[y][x] = T.USED_BLOCK;
        spawnParticles(x*TILE_SIZE+20, y*TILE_SIZE-20, '#FF0000');
        spawnEnemy(x*TILE_SIZE, y*TILE_SIZE-40);
        hitDamage();
    } else if(t===T.HIDDEN || t===T.HIDDEN_TRIGGER || t===T.TROLL_HIDDEN) {
        levelMap[y][x] = T.FACE_BLOCK; 
        spawnParticles(x*TILE_SIZE+20, y*TILE_SIZE+40, '#fff');
        if(player.vy < 0) { player.vy = 0; player.y = (y+1)*TILE_SIZE; }
    } else if(t===T.BLOCK && player.isBig) {
        levelMap[y][x] = T.EMPTY; spawnParticles(x*TILE_SIZE+20, y*TILE_SIZE+20, currentTheme.block); if(player.vy<0) player.vy = 0;
    }
}

function isSolid(t) { 
    return (t >= 1 && t <= 3) || (t >= 6 && t <= 12 && t !== T.FAKE) || 
    t===T.CEILING_SPIKE || t===T.HIDDEN_TRIGGER || t===T.COIN_BLOCK || t===T.MULTI_COIN_BLOCK || t===T.MEGA_COIN_BLOCK ||
    t===T.TRAP_COIN_BLOCK || t===T.FALL_TRAP || t===T.DELAY_FALL || t===T.FALLING_CLOUD || t===T.HIDDEN_SPIKE;
}
function getTile(x, y) { if(y<0||y>=levelMap.length||x<0||x>=levelMap[0].length) return T.EMPTY; return levelMap[y][x]; }
function intersect(a, b) { return a.x < b.x+b.w && a.x+a.w > b.x && a.y < b.y+b.h && a.y+a.h > b.y; }

function spawnItem(x, y, type) { 
    if (type === I.ENEMY_SPAWN) {
        spawnEnemy(x, y);
        return;
    }
    items.push({x:x, y:y, w:30, h:30, vx:2, vy:-5, type:type, active:false}); 
    setTimeout(()=>{ if(items.length>0) items[items.length-1].active=true; },300); 
}

function updateItems() { 
    for(let i=items.length-1; i>=0; i--) { 
        let it = items[i]; it.vy += GRAVITY; it.x += it.vx; 
        checkCollisionX(it); it.y += it.vy; checkCollisionY(it); 
        if(it.vx===0) it.vx=(Math.random()>0.5?2:-2); 
        if(it.active && intersect(player, it)) { 
            if(it.type===I.MUSHROOM) { 
                if(!player.isBig){player.isBig=true; player.y-=10; spawnParticles(player.x,player.y,'#ff0000');} 
            } else if(it.type===I.POISON || it.type===I.FAKE_GOOD || it.type===I.FAKE_GREY || it.type===I.FAKE_STAR) {
                die(); 
            } else if(it.type===I.FAKE || it.type===I.GREY) {
                spawnParticles(player.x,player.y,'#888'); // Poof
            } 
            items.splice(i,1); 
        } else if(it.y>GAME_HEIGHT+50) items.splice(i,1); 
    } 
}

function hitDamage() { if(activeCheats.god || player.invincible>0) return; if(player.isBig){ player.isBig=false; player.invincible=120; player.vy=-5; spawnParticles(player.x,player.y,'#fff'); } else die(); }

function die() { 
    if(activeCheats.god || player.dead) return; 
    player.dead = true; player.vy = -12; isTimerRunning = false; trail.push(null); saveData(); 
    keys.left=false; keys.right=false; keys.jump=false; keys.down=false;
    setTimeout(() => { 
        const cur = activeCheats.god ? '∞' : fmt(gameData.lives); 
        const nxt = activeCheats.god ? '∞' : fmt(gameData.lives - 1); 
        document.getElementById('dead-lives-info').innerText = `${cur} → ${nxt}`; 
        if(gameData.lives <= 0 && !allowNegativeLives && !activeCheats.god) { 
            document.getElementById('go-retry-btn').disabled=true; 
            showPanel('gameover-panel'); 
        } else {
            showPanel('dead-panel'); 
        }
    }, 800); 
}

function respawnPlayer() { 
    if(player.dead) { if(!activeCheats.god && !allowNegativeLives) gameData.lives--; if(allowNegativeLives) gameData.lives--; } 
    if(gameData.lives < 0 && !allowNegativeLives) { showPanel('gameover-panel'); return; } 
    saveData(); resetLevel(false); 
    gameState = 'PLAYING'; 
    showPanel(null); 
    isTimerRunning = true; 
}
function continueNegative() { allowNegativeLives = true; respawnPlayer(); }

function levelClear() { 
    isTimerRunning = false; 
    gameState = 'CLEARED'; 
    if(currentLevel >= gameData.maxReachedLevel && !activeCheats.unlock) { gameData.maxReachedLevel = currentLevel + 1; } 
    document.getElementById('result-time').innerText = formatTime(elapsedTime); 
    let isNewRecord = false; 
    if(!activeCheats.god && !activeCheats.flight) { if(!gameData.bestTimes[currentLevel] || elapsedTime < gameData.bestTimes[currentLevel]) { gameData.bestTimes[currentLevel] = elapsedTime; isNewRecord = true; } } 
    document.getElementById('new-record-msg').style.display = isNewRecord ? 'block' : 'none'; 
    const earned = activeCheats.infiniteCoins ? "∞" : fmt(gameData.coins - levelStartCoins); 
    document.getElementById('result-coins').innerText = earned; 
    document.getElementById('result-life-diff').innerText = `${fmt(levelStartLives)} → ${fmt(gameData.lives)}`; 
    const now = new Date(); 
    
    // 履歴データの保存 (livesを追加)
    gameData.history.push({ 
        date: `${now.getMonth()+1}/${now.getDate()} ${now.getHours()}:${now.getMinutes().toString().padStart(2,'0')}`, 
        level: currentLevel, 
        time: formatTime(elapsedTime), 
        coins: gameData.coins,
        lives: gameData.lives, 
        trail: [...trail] 
    }); 
    
    saveData(); 
    setTimeout(drawResultMap, 100); 
    showPanel('clear-panel'); 
}

function confirmSuicide() { 
    if(gameState !== 'PLAYING') return;
    isTimerRunning = false; 
    const cur = activeCheats.god?'∞':fmt(gameData.lives); 
    const nxt = activeCheats.god?'∞':fmt(gameData.lives-1); 
    document.getElementById('suicide-life-calc').innerText = `${cur} → ${nxt}`; 
    showPanel('suicide-panel'); 
}
function closeSuicide() { showPanel(null); isTimerRunning = true; }
function executeSuicide() { 
    if(!activeCheats.god && !allowNegativeLives) gameData.lives--; 
    if(allowNegativeLives) gameData.lives--; 
    saveData(); 
    if(gameData.lives < 0 && !allowNegativeLives) showPanel('gameover-panel'); else respawnPlayer(); 
}

function updateHUD() { 
    document.getElementById('disp-level').innerText = fmt(currentLevel); 
    const lSpan = document.getElementById('disp-lives'); 
    lSpan.innerText = activeCheats.god ? "∞" : fmt(gameData.lives); 
    lSpan.style.color = gameData.lives < 0 ? '#ff0000' : '#ff4d4d'; 
    document.getElementById('disp-coins').innerText = activeCheats.infiniteCoins ? "∞" : fmt(gameData.coins); 
    if(gameState === 'PLAYING' && isTimerRunning && startTime > 0) { elapsedTime = Date.now() - startTime; }
    document.getElementById('disp-time').innerText = formatTime(elapsedTime); 
}

function formatTime(ms) { 
    if(isNaN(ms) || ms < 0) return "00:00.00";
    const c = Math.floor((ms%1000)/10); const s = Math.floor((ms/1000)%60); const m = Math.floor((ms/60000)); 
    return `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}.${c.toString().padStart(2,'0')}`; 
}
function spawnParticles(x, y, color) { for(let i=0; i<6; i++) particles.push({x:x, y:y, vx:(Math.random()-0.5)*8, vy:(Math.random()-0.5)*8, color:color, life:20}); }

function draw() {
    ctx.fillStyle = currentTheme.bg; ctx.fillRect(0, 0, canvas.width, canvas.height);
    let camX = player.x - GAME_WIDTH / 2; if(camX < 0) camX = 0;
    ctx.save(); ctx.translate(-Math.floor(camX), 0);
    const startCol = Math.floor(camX/TILE_SIZE), endCol = startCol + (GAME_WIDTH/TILE_SIZE) + 2;
    for(let y=0; y<levelMap.length; y++) for(let x=startCol; x<=endCol; x++) if(x>=0 && x<levelMap[0].length) drawTile(ctx, x, y, levelMap[y][x]);
    
    // Draw Goal
    if(goalPole.x > camX - 50 && goalPole.x < camX + GAME_WIDTH + 50) drawGoalPole(ctx);
    
    for(let it of items) drawItem(it);
    for(let en of enemies) drawEnemy(en);
    for(let d of debris) drawDebris(d);

    if(laserActive) {
        ctx.strokeStyle = '#ff0000';
        ctx.lineWidth = 5;
        ctx.beginPath(); ctx.moveTo(goalPole.x+5, goalPole.y+10); ctx.lineTo(goalPole.x-1000, goalPole.y+100); ctx.stroke();
    }

    if(!player.dead || frameCount%2===0) { if(player.invincible%4 < 2) drawCat(player); }
    
    for(let p of particles) { p.x+=p.vx; p.y+=p.vy; p.life--; ctx.fillStyle=p.color; ctx.fillRect(p.x,p.y,6,6); }
    particles = particles.filter(p => p.life > 0);
    ctx.restore();
}
function drawGoalPole(c) { c.fillStyle = '#28a745'; c.fillRect(goalPole.x-10, goalPole.y+goalPole.h, 30, 40); c.fillStyle = '#eee'; c.fillRect(goalPole.x, goalPole.y, 10, goalPole.h); c.beginPath(); c.arc(goalPole.x+5, goalPole.y, 10, 0, Math.PI*2); c.fill(); c.fillStyle = '#ff3333'; c.beginPath(); const fy = goalPole.y + goalPole.h - 40 - goalPole.flagY; c.moveTo(goalPole.x+10, fy); c.lineTo(goalPole.x+50, fy+15); c.lineTo(goalPole.x+10, fy+30); c.fill(); }

function drawResultMap() { drawMapOnCanvas(document.getElementById('result-map-canvas').getContext('2d'), false, trail); }
function drawMapOnCanvas(c, hideSpoilers, trailData) {
    const cv = c.canvas; cv.width = cv.clientWidth * (window.devicePixelRatio || 1); cv.height = cv.clientHeight * (window.devicePixelRatio || 1);
    c.clearRect(0, 0, cv.width, cv.height);
    const mapW = levelMap[0].length * TILE_SIZE, mapH = levelMap.length * TILE_SIZE;
    let scale = cv.width / mapW; if(mapH * scale > cv.height) scale = cv.height / mapH;
    const drawSize = Math.max(scale * TILE_SIZE, 0.5);
    const offsetX = (cv.width - mapW*scale) / 2, offsetY = (cv.height - mapH*scale) / 2;
    c.save(); c.translate(offsetX, offsetY);
    
    for(let y=0; y<levelMap.length; y++) for(let x=0; x<levelMap[0].length; x++) {
        let t = levelMap[y][x];
        if(hideSpoilers) { 
            if(t===T.FAKE||t===T.FAKE_SPIKE||t===T.FALL_TRAP||t===T.DELAY_FALL||t===T.FALLING_CLOUD) t=T.GROUND; 
            if((t===T.FALL_TRAP||t===T.DELAY_FALL) && y<11) t=T.BLOCK; 
            if(t===T.FALLING) t=T.BLOCK;
            if(t===T.TRAP_COIN_BLOCK) t=T.MULTI_COIN_BLOCK;
            if(t===T.HIDDEN||t===T.INVISIBLE_DEATH||t===T.HIDDEN_TRIGGER||t===T.TROLL_HIDDEN||t===T.SKY_SPAWNER||t===T.HIDDEN_SPIKE||t===T.BG_FALL_TRIGGER) t=T.EMPTY; 
        }
        if(t!==T.EMPTY) {
            if(t===T.GROUND||t===T.FAKE||t===T.FALLING_CLOUD) c.fillStyle=currentTheme.ground; 
            else if(t===T.BLOCK||t===T.HARD_BLOCK||t===T.FALLING||t===T.FALL_TRAP||t===T.DELAY_FALL) c.fillStyle=currentTheme.block; 
            else if(t===T.SPIKE||t===T.CEILING_SPIKE||t===T.HIDDEN_SPIKE) c.fillStyle='#CCC';
            else if(t===T.POLE) { c.fillStyle='#eee'; c.fillRect(x*TILE_SIZE*scale+15*scale, y*TILE_SIZE*scale-200*scale, 10*scale, 240*scale); continue; } 
            else if(t===T.CHECKPOINT_ON) c.fillStyle='#0f0'; else if(t===T.CHECKPOINT) c.fillStyle='#ff0'; else if(t===T.COIN) c.fillStyle='#FFD700';
            else if(t===T.COIN_BLOCK||t===T.MULTI_COIN_BLOCK||t===T.Q_BLOCK||t===T.TRAP_COIN_BLOCK||t===T.MEGA_COIN_BLOCK) c.fillStyle='#DAA520'; 
            else continue;
            c.fillRect(x*TILE_SIZE*scale, y*TILE_SIZE*scale, drawSize, drawSize);
        }
    }
    if(trailData) {
        c.strokeStyle = '#FF0000'; c.lineWidth = Math.max(1, TILE_SIZE*scale); c.lineCap='round'; c.lineJoin='round'; c.globalAlpha=0.8;
        c.beginPath(); 
        let startNew=true;
        for(let i=0; i<trailData.length; i++) { if(trailData[i]===null){startNew=true; continue;} if(startNew){c.moveTo(trailData[i].x*scale, trailData[i].y*scale); startNew=false;} else c.lineTo(trailData[i].x*scale, trailData[i].y*scale); } 
        c.stroke();
    }
    c.globalAlpha=1.0; c.fillStyle='#FFF'; c.beginPath(); c.arc(player.x*scale+player.w/2*scale, player.y*scale+player.h/2*scale, drawSize, 0, Math.PI*2); c.fill();
    c.restore();
}

/** 
 * UPDATED CHARACTER DRAWING
 */
function drawCat(p) {
    const cx = p.x + p.w / 2;
    const cy = p.y + p.h / 2;

    ctx.save();
    ctx.translate(cx, cy);

    // Facing & Big Mode Scale
    if (p.isBig) ctx.scale(1.5, 1.5);
    if (!p.facingRight) ctx.scale(-1, 1);
    
    // Crouch Squash
    if (p.crouching) ctx.scale(1.2, 0.7);

    // Rotation (Dead or Action)
    if (p.dead) {
        ctx.rotate(frameCount * 0.2);
    } else if (p.isHipDropping) {
        ctx.rotate(Math.PI); // Upside down for hip drop
    }

    // --- BODY (Small, under head) ---
    ctx.fillStyle = '#FFFFFF';
    ctx.beginPath();
    // Rounded Rect Body
    ctx.roundRect(-8, 5, 16, 12, 5);
    ctx.fill();

    // --- HEAD (Large, "Chibi" style) ---
    ctx.beginPath();
    // Slightly wide circle
    ctx.ellipse(0, -4, 14, 12, 0, 0, Math.PI * 2);
    ctx.fill();

    // --- EARS ---
    ctx.fillStyle = '#FFFFFF';
    // Left Ear
    ctx.beginPath();
    ctx.moveTo(-10, -10);
    ctx.lineTo(-14, -18);
    ctx.lineTo(-4, -12);
    ctx.fill();
    // Right Ear
    ctx.beginPath();
    ctx.moveTo(10, -10);
    ctx.lineTo(14, -18);
    ctx.lineTo(4, -12);
    ctx.fill();

    // Inner Ears (Pink)
    ctx.fillStyle = '#FFB6C1';
    ctx.beginPath();
    ctx.moveTo(-10, -10);
    ctx.lineTo(-13, -16);
    ctx.lineTo(-6, -12);
    ctx.fill();
    
    ctx.beginPath();
    ctx.moveTo(10, -10);
    ctx.lineTo(13, -16);
    ctx.lineTo(6, -12);
    ctx.fill();

    // --- FACE ---
    ctx.fillStyle = '#333333';
    
    if (p.dead) {
        // X X Eyes
        ctx.lineWidth = 2;
        ctx.strokeStyle = '#333';
        ctx.beginPath(); ctx.moveTo(-6, -6); ctx.lineTo(-2, -2); ctx.moveTo(-2, -6); ctx.lineTo(-6, -2); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(6, -6); ctx.lineTo(2, -2); ctx.moveTo(2, -6); ctx.lineTo(6, -2); ctx.stroke();
    } else {
        // Cute Black Eyes
        ctx.beginPath();
        ctx.arc(-5, -3, 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(5, -3, 2, 0, Math.PI * 2);
        ctx.fill();
        
        // Shine in eyes
        ctx.fillStyle = '#FFF';
        ctx.beginPath(); ctx.arc(-4, -4, 0.8, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(6, -4, 0.8, 0, Math.PI*2); ctx.fill();

        // Mouth (Small 'w')
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(-2, 1);
        ctx.quadraticCurveTo(0, 3, 2, 1);
        ctx.stroke();

        // Cheeks (Pink)
        ctx.fillStyle = 'rgba(255, 182, 193, 0.6)';
        ctx.beginPath(); ctx.arc(-8, 0, 2, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(8, 0, 2, 0, Math.PI*2); ctx.fill();
    }

    // --- TAIL ---
    ctx.strokeStyle = '#FFFFFF';
    ctx.lineWidth = 4;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(-8, 10);
    // Tail animation
    const tailWag = p.dead ? 0 : Math.sin(frameCount * 0.2) * 3;
    ctx.quadraticCurveTo(-18, 5 + tailWag, -15, -2 + tailWag);
    ctx.stroke();

    // --- FEET (Run Animation) ---
    ctx.fillStyle = '#FFF';
    const runAnim = (Math.abs(p.vx) > 0.1 && !p.dead) ? Math.sin(frameCount * 0.8) * 3 : 0;
    
    // Left Foot
    ctx.beginPath();
    ctx.arc(-5 + runAnim, 16, 3, 0, Math.PI * 2);
    ctx.fill();
    
    // Right Foot
    ctx.beginPath();
    ctx.arc(5 - runAnim, 16, 3, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();
}

function drawEnemy(e) {
    const cx = e.x + e.w/2; const cy = e.y + e.h/2;
    ctx.save(); ctx.translate(cx, cy); if(e.vx > 0) ctx.scale(-1, 1); 
    ctx.fillStyle = '#8B4513'; ctx.beginPath(); ctx.ellipse(0, 4, 13, 10, 0, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(8, -4, 10, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.moveTo(4, -10); ctx.lineTo(2, -18); ctx.lineTo(12, -10); ctx.fill();
    ctx.beginPath(); ctx.moveTo(14, -10); ctx.lineTo(16, -18); ctx.lineTo(8, -10); ctx.fill();
    ctx.fillStyle = '#FFD700'; ctx.beginPath(); ctx.arc(6, -5, 2.5, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(12, -5, 2.5, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = 'black'; ctx.beginPath(); ctx.arc(6, -5, 1, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(12, -5, 1, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle = 'black'; ctx.lineWidth = 1.5; ctx.beginPath(); ctx.moveTo(4, -9); ctx.lineTo(8, -6); ctx.stroke(); ctx.beginPath(); ctx.moveTo(14, -9); ctx.lineTo(10, -6); ctx.stroke();
    ctx.fillStyle = '#5A2E0E'; const l = Math.sin(frameCount * 0.5) * 5; ctx.beginPath(); ctx.arc(-5 + l, 12, 3.5, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(5 - l, 12, 3.5, 0, Math.PI*2); ctx.fill();
    ctx.restore();
}
function drawDebris(d) {
    ctx.fillStyle = '#555'; ctx.fillRect(d.x, d.y, d.w, d.h);
    ctx.fillStyle = '#222'; ctx.fillRect(d.x+5, d.y+5, d.w-10, d.h-10);
    // Scary face
    ctx.fillStyle = 'white'; ctx.beginPath(); ctx.arc(d.x+10, d.y+10, 3, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(d.x+20, d.y+10, 3, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.moveTo(d.x+5, d.y+20); ctx.lineTo(d.x+15, d.y+25); ctx.lineTo(d.x+25, d.y+20); ctx.stroke();
}

function drawTile(c, x, y, t) {
    const px=x*TILE_SIZE, py=y*TILE_SIZE;
    if(t===T.HIDDEN||t===T.INVISIBLE_DEATH||t===T.HIDDEN_TRIGGER||t===T.TROLL_HIDDEN||t===T.SKY_SPAWNER||t===T.HIDDEN_SPIKE||t===T.BG_FALL_TRIGGER) return;
    
    // Normal Ground & Traps
    if(t===T.GROUND||t===T.FAKE||t===T.FAKE_SPIKE||t===T.FALLING_CLOUD) { 
        if(t===T.FALLING_CLOUD) {
             c.fillStyle='#FFF'; c.beginPath(); c.arc(px+10,py+10,10,0,Math.PI*2); c.arc(px+30,py+10,12,0,Math.PI*2); c.arc(px+20,py+20,10,0,Math.PI*2); c.fill();
        } else {
            c.fillStyle=currentTheme.ground; c.fillRect(px,py,TILE_SIZE,TILE_SIZE); 
            c.fillStyle=currentTheme.grass; c.fillRect(px,py,TILE_SIZE,10); 
        }
    }
    // Falling blocks
    else if(t===T.BLOCK || t===T.FALLING) { c.fillStyle=currentTheme.block; c.fillRect(px,py,TILE_SIZE,TILE_SIZE); c.strokeStyle='#5c3a21'; c.strokeRect(px,py,TILE_SIZE,TILE_SIZE); }
    // Fall Trap disguise
    else if(t===T.FALL_TRAP || t===T.DELAY_FALL) {
        if (y >= 10) {
            c.fillStyle=currentTheme.ground; c.fillRect(px,py,TILE_SIZE,TILE_SIZE); 
            c.fillStyle=currentTheme.grass; c.fillRect(px,py,TILE_SIZE,10); 
        } else {
            c.fillStyle=currentTheme.block; c.fillRect(px,py,TILE_SIZE,TILE_SIZE); c.strokeStyle='#5c3a21'; c.strokeRect(px,py,TILE_SIZE,TILE_SIZE);
        }
    }

    else if(t===T.HARD_BLOCK) { c.fillStyle=currentTheme.hard; c.fillRect(px,py,TILE_SIZE,TILE_SIZE); c.strokeRect(px,py,TILE_SIZE,TILE_SIZE); }
    else if(t===T.FAKE_SPIKE) { c.fillStyle='#C0C0C0'; c.beginPath(); c.moveTo(px,py+TILE_SIZE); c.lineTo(px+20,py+5); c.lineTo(px+40,py+TILE_SIZE); c.fill(); }
    
    // Coin Blocks
    else if(t===T.Q_BLOCK || t===T.COIN_BLOCK) { 
        c.fillStyle=t===T.COIN_BLOCK?'#FFD700':'#FFA500'; 
        c.fillRect(px,py,TILE_SIZE,TILE_SIZE); c.fillStyle='#B8860B'; c.font='bold 24px sans-serif'; c.textAlign='center'; c.fillText(t===T.COIN_BLOCK?'$':'?',px+20,py+30); c.strokeRect(px,py,TILE_SIZE,TILE_SIZE); 
    }
    else if(t===T.MULTI_COIN_BLOCK || t===T.TRAP_COIN_BLOCK) { 
        c.fillStyle='#FF69B4'; c.fillRect(px,py,TILE_SIZE,TILE_SIZE); c.fillStyle='#C71585'; c.font='bold 24px sans-serif'; c.textAlign='center'; c.fillText('$',px+20,py+30); c.strokeRect(px,py,TILE_SIZE,TILE_SIZE); 
    }
    // MEGA COIN BLOCK (New)
    else if(t===T.MEGA_COIN_BLOCK) {
        // Gold with sparkle pattern
        c.fillStyle = '#FFD700'; 
        c.fillRect(px,py,TILE_SIZE,TILE_SIZE);
        c.fillStyle = '#FFFACD'; // Light yellow shine
        c.beginPath(); c.moveTo(px, py); c.lineTo(px+15, py); c.lineTo(px, py+15); c.fill();
        c.fillStyle='#8B4500'; c.font='bold 24px sans-serif'; c.textAlign='center'; c.fillText('★',px+20,py+30); 
        c.strokeRect(px,py,TILE_SIZE,TILE_SIZE); 
    }
    
    else if(t===T.USED_BLOCK) { c.fillStyle='#5c3a21'; c.fillRect(px,py,TILE_SIZE,TILE_SIZE); c.strokeRect(px,py,TILE_SIZE,TILE_SIZE); }
    else if(t===T.FACE_BLOCK) { 
        c.fillStyle='#DDDDDD'; c.fillRect(px,py,TILE_SIZE,TILE_SIZE); c.strokeRect(px,py,TILE_SIZE,TILE_SIZE); 
        c.fillStyle='black'; 
        c.beginPath(); c.arc(px+10, py+12, 2, 0, Math.PI*2); c.fill(); 
        c.beginPath(); c.arc(px+30, py+12, 2, 0, Math.PI*2); c.fill();
        c.beginPath(); c.moveTo(px+5, py+25); c.quadraticCurveTo(px+20, py+35, px+35, py+25); c.stroke();
        c.lineWidth = 0.5; c.beginPath(); c.moveTo(px+5, py+10); c.lineTo(px+15, py+8); c.stroke();
        c.beginPath(); c.moveTo(px+35, py+10); c.lineTo(px+25, py+8); c.stroke();
    }
    else if(t===T.SPIKE) { c.fillStyle='#C0C0C0'; c.beginPath(); c.moveTo(px,py+TILE_SIZE); c.lineTo(px+20,py+5); c.lineTo(px+40,py+TILE_SIZE); c.fill(); }
    else if(t===T.CEILING_SPIKE) { c.fillStyle='#C0C0C0'; c.beginPath(); c.moveTo(px,py); c.lineTo(px+20,py+35); c.lineTo(px+40,py); c.fill(); }
    else if(t===T.CHECKPOINT||t===T.CHECKPOINT_ON) { c.fillStyle='#555'; c.fillRect(px+5,py+10,5,30); c.fillStyle=(t===T.CHECKPOINT_ON)?'#00FF00':'#FF0000'; c.beginPath(); c.moveTo(px+10,py+10); c.lineTo(px+35,py+20); c.lineTo(px+10,py+30); c.fill(); }
    else if(t===T.COIN) { c.fillStyle='#FFD700'; c.beginPath(); c.arc(px+20, py+20, 12, 0, Math.PI*2); c.fill(); c.fillStyle='#DAA520'; c.font='16px monospace'; c.textAlign='center'; c.fillText('$', px+20, py+25); }
}
function drawItem(it) {
    const cx=it.x+it.w/2, cy=it.y+it.h/2; ctx.save(); ctx.translate(cx,cy);
    
    // Determine Color
    if(it.type===I.MUSHROOM || it.type===I.FAKE_GOOD) ctx.fillStyle='#FF3333'; 
    else if(it.type===I.POISON) ctx.fillStyle='#800080'; 
    else if(it.type===I.GREY || it.type===I.FAKE_GREY) ctx.fillStyle='#888';
    else if(it.type===I.FAKE_STAR) ctx.fillStyle='#FFD700';
    else ctx.fillStyle='#AAA';

    if(it.type===I.FAKE_STAR) {
        ctx.beginPath(); 
        for(let i=0; i<5; i++){ ctx.lineTo(Math.cos((18+i*72)/180*Math.PI)*15, -Math.sin((18+i*72)/180*Math.PI)*15); ctx.lineTo(Math.cos((54+i*72)/180*Math.PI)*7, -Math.sin((54+i*72)/180*Math.PI)*7); }
        ctx.closePath(); ctx.fill();
        ctx.fillStyle='black'; ctx.beginPath(); ctx.moveTo(-5,-2); ctx.lineTo(-2,2); ctx.stroke(); ctx.moveTo(5,-2); ctx.lineTo(2,2); ctx.stroke();
    } else {
        ctx.beginPath(); ctx.arc(0,-5,15,Math.PI,0); ctx.fill(); ctx.fillStyle='#FFEBCD'; ctx.beginPath(); ctx.ellipse(0,5,9,9,0,0,Math.PI*2); ctx.fill();
        // Poison Skull
        if(it.type===I.POISON || it.type===I.FAKE_GOOD || it.type===I.FAKE_GREY) { 
            if(it.type===I.POISON) {
                ctx.fillStyle='white'; ctx.beginPath(); ctx.moveTo(-4,-4); ctx.lineTo(4,4); ctx.moveTo(4,-4); ctx.lineTo(-4,4); ctx.stroke(); 
            }
        } 
    } 
    ctx.restore();
}

// Input
window.addEventListener('keydown', e => {
    if(e.key==='Escape') { togglePause(); return; }
    if(!canControl()) return; 
    if(e.key==='ArrowLeft'||e.key==='a') keys.left=true; 
    if(e.key==='ArrowRight'||e.key==='d') keys.right=true;
    if(e.key==='ArrowUp'||e.key==='w') keys.up=true; 
    if(e.key==='ArrowDown'||e.key==='s') { keys.down=true; keys.hipPressed=true; }
    if(e.key==='Shift') keys.run=true; 
    if(e.key===' '&&!e.repeat) { keys.jump=true; keys.jumpPressed=true; }
});
window.addEventListener('keyup', e => {
    if(e.key==='ArrowLeft'||e.key==='a') keys.left=false; 
    if(e.key==='ArrowRight'||e.key==='d') keys.right=false;
    if(e.key==='ArrowUp'||e.key==='w') keys.up=false; 
    if(e.key==='ArrowDown'||e.key==='s') keys.down=false;
    if(e.key==='Shift') keys.run=false; 
    if(e.key===' ') keys.jump=false;
});
</script>
</body>
</html>
